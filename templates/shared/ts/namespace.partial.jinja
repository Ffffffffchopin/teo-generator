{% for e in outline.enums() %}
    /**
     * **{{ e.title() }}**
     *
     * {{ e.desc() }}
     */
export type {{ e.name() }} = {{ e.joined_enum_variant_names_for_ts() }}
{% endfor %}

{% for interface in outline.interfaces() %}
/**
 * **{{ interface.title() }}**
 *
 * {{ interface.desc() }}
 */
export type {{ interface.name() }}{{ interface.generics_declaration() }} = {{ ts_extends(interface.extends()) }}{
    {% for field in interface.fields() %}
    /**
     * **{{ field.title() }}**
     *
     * {{ field.desc() }}
     */
     {{ field.name() }}{%- if field.type().is_optional() -%}?{%- endif -%}: {{ lookup(field.type().unwrap_optional(), false).unwrap() }}
    {% endfor %}
}
{%- if interface.is_output_result() %}
export type {{ interface.name() }}GetPayload<S extends boolean | null | undefined | {{ interface.model_name() }}Args, U = keyof S> = S extends true
    ? {{ interface.model_name() }}
    : S extends undefined
        ? never
        : S extends {{ interface.model_name() }}Args | {{ interface.model_name() }}FindManyArgs
            ? 'include' extends U
                ? SelectSubset<{{ interface.model_name() }}, S> & {
                    [P in ExistKeys<S['include']>]:
                    {%- for field in interface.fields() %}
                        {%- if field.is_relation() %}
                        P extends '{{ field.name()|camelcase }}' ? {{ lookup(field.type().unwrap_optional().unwrap_array().unwrap_optional(), false).unwrap() }}GetPayload<S['include'][P]>{{ get_payload_suffix(field.type()) }} :
                        {%- endif %}
                    {%- endfor %}
                    never
                }
                : SelectSubset<{{ interface.model_name() }}, S>
            : {{ interface.model_name() }}
    {%- endif %}
{% endfor %}

{% for ns in namespace.namespaces.values() %}
{{ render_namespace(ns, conf, main_namespace, mode.clone()) }}
{% endfor %}

{% if conf.is_client() %}
{% for delegate in outline.delegates() %}
export interface {{ delegate.name_with_conf(conf.class_name().to_string()) }} {

    {% for request_item in delegate.request_items() %}
    {{ request_item.name() }}<T extends {{ lookup(request_item.input_type().unwrap_optional(), false).unwrap() }}>({%- if request_item.has_custom_url_args() -%}pathArgs: {[key: string]: string}, {%- endif -%}{%- if request_item.has_body_input() -%}body: {%- if request_item.is_form() -%}FormData{%- else -%}T{%- endif -%}, {%- endif -%}headers?: {[key: string]: string} | undefined, queryString?: string | undefined): Promise<{{ lookup(request_item.output_type().unwrap_optional(), true).unwrap() }}>
    {% endfor %}

    {% for namespace_item in delegate.namespace_items() %}
    {{ namespace_item.property_name() }}: {{ namespace_item.path().join(".") }}
    {% endfor %}

    {% for group_item in delegate.group_items() %}
    {{ group_item.property_name() }}: {{ group_item.path().join(".") }}
    {% endfor %}

    /**
     * Get a new client altered with `headers`.
     * @param {headers?} headers - The new headers.
     */
    $headers(headers?: {[key: string]: string} | undefined): {{ conf.class_name().to_string() }}
}
{% endfor %}

{% if namespace.path().is_empty() %}
/**
 * ## {{ conf.class_name().to_string() }} API Client
 *
 * {{ conf.class_name().to_string() }} API client for TypeScript & javaScript. It supports both browser and
 * node.js. It's generated by the fantastic Teo framework.
 *
 */
export const {{ conf.object_name().to_string() }}: {{ conf.class_name().to_string() }}
{% endif %}
{%- endif %}