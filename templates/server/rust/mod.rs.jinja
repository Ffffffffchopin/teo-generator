use std::borrow::Borrow;
use std::fmt::{Debug, Display, Formatter};
use std::future::Future;
{%- if has_date %}
use chrono::NaiveDate;
{%- endif %}
{%- if has_datetime %}
use chrono::{DateTime, Utc};
{%- endif %}
{%- if has_decimal %}
use bigdecimal::BigDecimal;
{%- endif %}
{%- if has_object_id %}
use bson::oid::ObjectId;
{%- endif %}
use teo::core::callbacks::params::callback::{CallbackParam, ExtractFromCallbackParam};
use teo::core::callbacks::params::compare::{CompareParam, ExtractFromCompareParam};
use teo::core::ctx::user::UserCtx;
use teo::prelude::{Object, Value, Result, ModelCtx, ExtractValueFromReqCtx, ReqCtx};
use teo::teon;
{%- if outline.enums.len() > 0 %}
use teo::core::error::*;

pub trait EnumVariantToValue {
    fn to_enum_value(&self) -> Value;
}

trait ValueToEnumVariant<T> {
    fn to_enum_variant(&self) -> Result<T>;
}
{%- endif %}


{%- for e in outline.enums %}
/// ## {{ e.localized_name }}
///
/// {{ e.desc }}
#[derive(Eq, PartialEq, Copy, Clone, Debug)]
pub enum {{ e.name }} {
{%- for v in e.variants %}
    /// ### {{ v.localized_name }}
    ///
    /// {{ v.desc }}
    {{ v.name }},
{%- endfor %}
}

impl EnumVariantToValue for {{ e.name }} {
    fn to_enum_value(&self) -> Value {
        match self {
{%- for v in e.variants %}
            {{ e.name }}::{{ v.name }} => Value::String("{{ v.name }}".to_owned()),
{%- endfor %}
        }
    }
}

impl EnumVariantToValue for Option<{{ e.name }}> {
    fn to_enum_value(&self) -> Value {
        if self.is_none() {
            return Value::Null;
        }
        match self.unwrap() {
{%- for v in e.variants %}
            {{ e.name }}::{{ v.name }} => Value::String("{{ v.name }}".to_owned()),
{%- endfor %}
        }
    }
}

impl ValueToEnumVariant<{{ e.name }}> for Value {
    fn to_enum_variant(&self) -> Result<{{ e.name }}> {
        if self.is_string() {
            Ok(match self.as_str().unwrap() {
{%- for v in e.variants %}
                "{{ v.name }}" => {{ e.name }}::{{ v.name }},
{%- endfor %}
                _ => return Err(Error::RuntimeError(RuntimeError::CannotConvertValueToEnumVariant))
            })
        } else {
            Err(Error::RuntimeError(RuntimeError::CannotConvertValueToEnumVariant))
        }
    }
}

impl ValueToEnumVariant<Option<{{ e.name }}>> for Value {
    fn to_enum_variant(&self) -> Result<Option<{{ e.name }}>> {
        if self.is_string() {
            Ok(Some(match self.as_str().unwrap() {
{%- for v in e.variants %}
                "{{ v.name }}" => {{ e.name }}::{{ v.name }},
{%- endfor %}
                _ => return Err(Error::RuntimeError(RuntimeError::CannotConvertValueToEnumVariant))
            }))
        } else if self.is_null() {
            Ok(None)
        } else {
            Err(Error::RuntimeError(RuntimeError::CannotConvertValueToEnumVariant))
        }
    }
}
{%- endfor %}

{%- for class in outline.classes %}
pub struct {{ class.name }}Class {
    pub model_ctx: ModelCtx,
}

impl {{ class.name }}Class {

    /// Find many {{ class.name|wordcase|pluralize }}.
    pub async fn find_many(&self, query: impl Borrow<Value>) -> Result<Vec<{{ class.name }}>> {
        self.model_ctx.find_many(query.borrow()).await
    }

    /// Find a unique {{ class.name|wordcase }}.
    pub async fn find_unique(&self, query: impl Borrow<Value>) -> Result<Option<{{ class.name }}>> {
        self.model_ctx.find_unique(query.borrow()).await
    }

    /// Find a non unique {{ class.name|wordcase }}.
    pub async fn find_first(&self, query: impl Borrow<Value>) -> Result<Option<{{ class.name }}>> {
        self.model_ctx.find_first(query.borrow()).await
    }

    /// Create a new {{ class.name|wordcase }}.
    pub async fn new(&self, values: impl Borrow<Value>) -> Result<{{ class.name }}> {
        self.model_ctx.create_object::<{{ class.name }}>(values.borrow()).await
    }

    /// Create an empty {{ class.name|wordcase }}.
    pub async fn default(&self) -> Result<{{ class.name }}> {
        self.model_ctx.create_object::<{{ class.name }}>(teon!({}).borrow()).await
    }

    /// Count on {{ class.name|wordcase }}.
    pub async fn count(&self, query: impl Borrow<Value>) -> Result<usize> {
        self.model_ctx.count(query.borrow()).await
    }

    /// Aggregate on {{ class.name|wordcase }}.
    pub async fn aggregate(&self, query: impl Borrow<Value>) -> Result<{{ class.name }}AggregateResult> {
        self.model_ctx.aggregate(query.borrow()).await
    }

    /// Group by on {{ class.name|wordcase }}.
    pub async fn group_by(&self, query: impl Borrow<Value>) -> Result<Vec<{{ class.name }}AggregateResult>> {
        self.model_ctx.group_by(query.borrow()).await
    }

}

#[derive(Clone)]
pub struct {{ class.name }} {
    pub inner: Object,
}

impl {{ class.name }} {

    /// Whether this {{ class.name|wordcase }} is new.
    pub fn is_new(&self) -> bool {
        self.inner.is_new()
    }

    /// Whether this {{ class.name|wordcase }} is modified.
    pub fn is_modified(&self) -> bool {
        self.inner.is_modified()
    }

    /// Set new values to a {{ class.name|wordcase }}. Validations and transformations are
    /// triggered.
    pub async fn set(&self, values: impl AsRef<Value>) -> Result<()> {
        self.inner.set_teon(values.as_ref()).await
    }

    /// Update with new values to a {{ class.name|wordcase }}. Validations and transformations are
    /// not triggered.
    pub async fn update(&self, values: impl AsRef<Value>) -> Result<()> {
        self.inner.update_teon(values.as_ref()).await
    }

    /// Save this {{ class.name|wordcase }}.
    pub async fn save(&self) -> Result<()> {
        self.inner.save().await
    }

    /// Delete this {{ class.name|wordcase }}.
    pub async fn delete(&self) -> Result<()> {
        self.inner.delete().await
    }

{%- for field in class.fields %}
{%- if field.kind.is_field() %}
    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub fn {{ field.name|snakecase }}(&self) -> {{ field.output_field_type }} {
    {%- if field.is_enum %}
        let value: Value = self.inner.get("{{ field.name }}").unwrap();
        value.to_enum_variant().unwrap()
    {%- else %}
        self.inner.get("{{ field.name }}").unwrap()
    {%- endif %}
    }

    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub fn set_{{ field.name|snakecase }}(&self, new_value: {{ field.input_field_type }}) {
    {%- if field.is_enum %}
        self.inner.set("{{ field.name }}", new_value.to_enum_value()).unwrap();
    {%- else %}
        self.inner.set("{{ field.name }}", new_value).unwrap();
    {%- endif %}
    }

{%- else if field.kind.is_relation() %}
{%- if field.input_field_type.as_ref().contains("Vec<") %}
    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn {{ field.name|snakecase }}(&self, find_many_input: impl AsRef<Value>) -> Vec<{{ field.input_field_type }}> {
        let objects = self.inner.force_get_relation_objects("{{ field.name }}", find_many_input.as_ref()).await.unwrap();
        objects.iter().map(|o| {{ field.input_field_type }} { inner: o.clone() }).collect()
    }

    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn set_{{ field.name|snakecase }}(&self, {{ field.name }}: {{ field.input_field_type }}) {
        let objects = {{ field.name }}.iter().map(|o| o.inner.clone()).collect();
        self.inner.force_set_relation_objects("{{ field.name }}", objects).await
    }

    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn add_to_{{ field.name|snakecase }}(&self, {{ field.name }}: {{ field.input_field_type }}) {
        let objects = {{ field.name }}.iter().map(|o| o.inner.clone()).collect();
        self.inner.force_add_relation_objects("{{ field.name }}", objects).await
    }

    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn remove_from_{{ field.name|snakecase }}(&self, {{ field.name }}: {{ field.input_field_type }}) {
        let objects = {{ field.name }}.iter().map(|o| o.inner.clone()).collect();
        self.inner.force_remove_relation_objects("{{ field.name }}", objects).await
    }
{%- else %}
    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn {{ field.name|snakecase }}(&self) -> {% if field.input_optional %}Option<{% endif %}{{ field.input_field_type }}{% if field.input_optional %}>{% endif %} {
        let object = self.inner.force_get_relation_object("{{ field.name }}").await.unwrap();
        {% if field.input_optional %}
        match object {
            Some(object) => Some({{ field.input_field_type }} { inner: object }),
            None => None,
        }
        {% else %}
        {{ field.input_field_type }} { inner: object.unwrap() }
        {% endif %}
    }

    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn set_{{ field.name|snakecase }}(&self, {{ field.name }}: {% if field.input_optional %}Option<{% endif %}{{ field.input_field_type }}{% if field.input_optional %}>{% endif %}) {
        self.inner.force_set_relation_object("{{ field.name }}", {% if !field.input_optional %}Some({% endif %}{{ field.name }}{% if field.input_optional %}.map(|o| o.inner.clone()){% else %}.inner.clone(){% if !field.input_optional %}){% endif %}{% endif %}).await
    }
{%- endif %}
{%- else if field.kind.is_property() %}
{%- if field.getter %}
    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn {{ field.name|snakecase }}(&self) -> Result<{{ field.output_field_type }}> {
    {%- if field.is_enum %}
        let value: Value = self.inner.get_property("{{ field.name }}").await;
        value.to_enum_variant()
    {%- else %}
        self.inner.get_property("{{ field.name }}").await
    {%- endif %}
    }
{%- endif %}
{%- if field.setter %}
    /// ## {{ field.localized_name }}
    ///
    /// {{ field.desc }}
    pub async fn set_{{ field.name|snakecase }}(&self, new_value: {{ field.input_field_type }}) -> Result<()> {
    {%- if field.is_enum %}
        self.inner.set_property("{{ field.name }}", new_value.to_enum_value()).await
    {%- else %}
        self.inner.set_property("{{ field.name }}", new_value).await
    {%- endif %}

    }
{%- endif %}
{%- endif %}
{%- endfor %}
}

impl Into<Object> for {{ class.name }} {
    fn into(self) -> Object {
        self.inner.clone()
    }
}

impl From<Object> for {{ class.name }} {
    fn from(value: Object) -> Self {
        Self { inner: value }
    }
}

impl Into<Value> for {{ class.name }} {
    fn into(self) -> Value {
        Value::Object(self.into())
    }
}

impl From<Value> for {{ class.name }} {
    fn from(value: Value) -> Self {
        Self::from(value.as_object().unwrap().clone())
    }
}

impl Debug for {{ class.name }} {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Debug::fmt(&self.inner, f)
    }
}

impl Display for {{ class.name }} {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.inner, f)
    }
}

impl ExtractFromCallbackParam for {{ class.name }} {
    fn extract(param: &CallbackParam) -> Self {
        Self { inner: param.object.clone() }
    }
}

impl ExtractFromCompareParam for {{ class.name }} {
    fn extract(param: &CompareParam) -> Self {
        Self { inner: param.object.clone() }
    }
}

#[derive(Clone)]
pub struct {{ class.name }}AggregateResult {
    pub inner: Value,
}

impl From<Value> for {{ class.name }}AggregateResult {
    fn from(value: Value) -> Self {
        Self { inner: value }
    }
}

impl {{ class.name }}AggregateResult {

    pub fn _count__all(&self) -> Option<usize> {
        self.inner.get("_count").map(|r| r.get("_all").cloned()).flatten().map(|v| v.as_usize()).flatten()
    }

    {%- for field in class.fields %}
    {%- if field.aggregate.is_some() %}

    {%- if field.aggregate().can_count %}
    pub fn _count_{{ field.name|snakecase }}(&self) -> Option<usize> {
        self.inner.get("_count").map(|r| r.get("{{ field.name }}").cloned()).flatten().map(|v| v.as_usize()).flatten()
    }
    {%- endif %}

    {%- if field.aggregate().can_max %}
    pub fn _max_{{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().max_type|rust_ref_if_needed }}> {
        if self.inner.get("_max").is_some() {
            let value = self.inner.get("_max").unwrap().get("{{ field.name }}");
            if value.is_some() {
                value.unwrap().as_{{ field.aggregate().max_type|rust_as }}()
            } else {
                None
            }
        } else {
            None
        }
    }
    {%- endif %}

    {%- if field.aggregate().can_min %}
    pub fn _min_{{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().min_type|rust_ref_if_needed }}> {
        if self.inner.get("_min").is_some() {
            let value = self.inner.get("_min").unwrap().get("{{ field.name }}");
            if value.is_some() {
                value.unwrap().as_{{ field.aggregate().min_type|rust_as }}()
            } else {
                None
            }
        } else {
            None
        }
    }
    {%- endif %}

    {%- if field.aggregate().can_avg %}
    pub fn _avg_{{ field.name|snakecase }}(&self) -> Option<f64> {
        self.inner.get("_avg").map(|r| r.get("{{ field.name }}").cloned()).flatten().map(|v| v.as_f64()).flatten()
    }
    {%- endif %}

    {%- if field.aggregate().can_sum %}
    pub fn _sum_{{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().sum_type }}> {
        self.inner.get("_sum").map(|r| r.get("{{ field.name }}").cloned()).flatten().map(|v| v.as_{{ field.aggregate().sum_type }}()).flatten()
    }
    {%- endif %}

    {%- if field.aggregate().can_group_by %}
    pub fn {{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().group_by_type.as_ref().unwrap()|rust_ref_if_needed }}> {
        if self.inner.get("{{ field.name }}").is_some() {
            let value = self.inner.get("{{ field.name }}").unwrap().get("{{ field.name }}");
            if value.is_some() {
                value.unwrap().as_{{ field.aggregate().group_by_type.as_ref().unwrap()|rust_as }}()
            } else {
                None
            }
        } else {
            None
        }
    }
    {%- endif %}

    {%- endif %}
    {%- endfor %}

}

{%- endfor %}

pub struct Teo {
    user_ctx: UserCtx,
}

impl ExtractValueFromReqCtx for Teo {
    fn extract(param: &ReqCtx) -> Self {
        Self { user_ctx: param.user_ctx.clone() }
    }
}

impl ExtractFromCallbackParam for Teo {
    fn extract(param: &CallbackParam) -> Self {
        Self { user_ctx: param.user_ctx.clone() }
    }
}

impl ExtractFromCompareParam for Teo {
    fn extract(param: &CompareParam) -> Self {
        Self { user_ctx: param.user_ctx.clone() }
    }
}

impl From<UserCtx> for Teo {
    fn from(value: UserCtx) -> Self {
        Self { user_ctx: value }
    }
}

impl Teo {

    pub async fn transaction<F, C, Fut, R>(&self, f: F) -> Result<R> where
        F: Fn(C) -> Fut,
        C: From<UserCtx>,
        Fut: Future<Output = Result<R>> {
        self.user_ctx.transaction(f).await
    }


{%- for class in outline.classes %}
    pub fn {{ class.name|snakecase }}(&self) -> {{ class.name }}Class {
        {{ class.name }}Class { model_ctx: self.user_ctx.model_ctx("{{ class.name }}").unwrap() }
    }
{%- endfor %}
}