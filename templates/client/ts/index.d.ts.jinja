import Decimal from "decimal.js"

export type ExistKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

type HasSelect = {
    select: any
}

type HasInclude = {
    include: any
}

export type CheckSelectInclude<T, S, U> = T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

export type SelectSubset<T, U> = U extends HasSelect
    ? {
        [K in ExistKeys<U['select']>]: K extends keyof T ? T[K] : never
    }
    : T

export type Enumerable<T> = T | Array<T>

export declare class TeoError extends Error {

    type: string

    fields: {[key: string]: string} | null

    constructor(responseError: ResponseError)

    get name(): string
}
{% for class in outline.classes %}
    {%- if class.kind.is_any_kind_of_enum() %}
export type {{ class.model_name }}{{ class.name_suffix }} = {{ class.joined_enum_variant_names() }}
    {%- else %}
export type {{ class.model_name }}{{ class.name_suffix }} = {
        {%- for field in class.fields %}
            {%- if field.docs.len() > 0 || field.localized_name.len() > 0 %}
    /**
     {%- if field.localized_name.len() > 0 %}
     * **{{ field.localized_name }}**{% endif %}
     {%- if field.docs.len() > 0 %}
     * {{ field.docs }}{% endif %}
     */
            {%- endif %}
    {{ field.name|escape_ts }}{%- if field.optional %}?{% endif %}: {{ field.field_type }}
        {%- endfor %}
}
    {%- endif %}
    {%- if class.kind.is_output() %}
export type {{ class.model_name }}GetPayload<S extends boolean | null | undefined | {{ class.model_name }}Args, U = keyof S> = S extends true
    ? {{ class.model_name }}
    : S extends undefined
        ? never
        : S extends {{ class.model_name }}Args | {{ class.model_name }}FindManyArgs
            ? 'include' extends U
                ? SelectSubset<{{ class.model_name }}, S> & {
                    [P in ExistKeys<S['include']>]:
                    {%- for field in class.fields %}
                        {%- if field.kind.is_relation() %}
                        P extends '{{ field.name|camelcase }}' ? {{ field.field_type }}GetPayload<S['include'][P]> :
                        {%- endif %}
                    {%- endfor %}
                    never
                }
                : SelectSubset<{{ class.model_name }}, S>
            : {{ class.model_name }}
    {%- endif %}
{%- endfor %}

{% for delegate in outline.delegates %}
declare class {{ delegate.model_name }}Delegate {
{%- for action in delegate.actions %}
    /**
     * {{ action.docs }}
     * @param {{ "{" }}{{ delegate.model_name }}{{ action.name|capitalize_first }}Args{{ "}" }} args - Arguments to {{ action.docs|wordcase }}
     * @example
     * // {{ action.docs }}
     * const result = await {{ conf.object_name }}.{{ delegate.model_name|camelcase }}.{{ action.name }}({
     *     // data to {{ action.docs|wordcase }}
     * })
     */
    {{ action.name }}<T extends {{ delegate.model_name }}{{ action.name|capitalize_first }}Args>(args?: T): Promise<{{ action.response }}>
{%- endfor %}
}
{% endfor %}

declare class {{ conf.class_name() }} {
{% for delegate in outline.delegates %}
    /**
     * ## {{ delegate.model_localized_name }}
     *
     * {{ delegate.model_description }}
     *
     * @example
     * ```ts
     * // Fetch zero or more {{ delegate.model_name|pluralize|wordcase }}
     * const { {{ delegate.model_name|camelcase }}: data } = await teo.{{ delegate.model_name|camelcase }}.findMany()
     * ```
     *
     */
    {{ delegate.model_name|camelcase }}: {{ delegate.model_name|capitalize_first }}Delegate
{% endfor %}

    /**
     * Create a new {{ conf.class_name() }} client instance.
     */
    constructor(token?: string)
    /**
     * Get a new client altered with `token`. This is useful if you use this on a backend server.
     * @param {string?} token - The new identity token.
     */
    $withToken(token?: string): {{ conf.class_name() }}
}

/**
 * ##  {{ conf.class_name() }} API Client
 *
 * {{ conf.class_name() }} API client for TypeScript & javaScript. It supports both browser and
 * node.js. It's generated by the fantastic Teo framework.
 *
 * @example
 * ```ts
 * // Fetch zero or more {{ outline.example_model().model_name|pluralize|wordcase }}
 * const { {{ outline.example_model().model_name|camelcase }}: data } = await {{ conf.object_name }}.{{ outline.example_model().model_name|camelcase }}.findMany()
 * ```
 *
 */
export const {{ conf.object_name }}: {{ conf.class_name() }}
