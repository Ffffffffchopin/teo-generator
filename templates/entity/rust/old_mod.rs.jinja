impl ExtractFromCallbackParam for {{ class.name }} {
    fn extract(param: &CallbackParam) -> Self {
        Self { inner: param.object.clone() }
    }
}

impl ExtractFromCompareParam for {{ class.name }} {
    fn extract(param: &CompareParam) -> Self {
        Self { inner: param.object.clone() }
    }
}

#[derive(Clone)]
pub struct {{ class.name }}AggregateResult {
    pub inner: Value,
}

impl From<Value> for {{ class.name }}AggregateResult {
    fn from(value: Value) -> Self {
        Self { inner: value }
    }
}

impl {{ class.name }}AggregateResult {

    pub fn _count__all(&self) -> Option<usize> {
        self.inner.get("_count").map(|r| r.get("_all").cloned()).flatten().map(|v| v.as_usize()).flatten()
    }

    {%- for field in class.fields %}
    {%- if field.aggregate.is_some() %}

    {%- if field.aggregate().can_count %}
    pub fn _count_{{ field.name|snakecase }}(&self) -> Option<usize> {
        self.inner.get("_count").map(|r| r.get("{{ field.name }}").cloned()).flatten().map(|v| v.as_usize()).flatten()
    }
    {%- endif %}

    {%- if field.aggregate().can_max %}
    pub fn _max_{{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().max_type|rust_ref_if_needed }}> {
        if self.inner.get("_max").is_some() {
            let value = self.inner.get("_max").unwrap().get("{{ field.name }}");
            if value.is_some() {
                value.unwrap().as_{{ field.aggregate().max_type|rust_as }}()
            } else {
                None
            }
        } else {
            None
        }
    }
    {%- endif %}

    {%- if field.aggregate().can_min %}
    pub fn _min_{{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().min_type|rust_ref_if_needed }}> {
        if self.inner.get("_min").is_some() {
            let value = self.inner.get("_min").unwrap().get("{{ field.name }}");
            if value.is_some() {
                value.unwrap().as_{{ field.aggregate().min_type|rust_as }}()
            } else {
                None
            }
        } else {
            None
        }
    }
    {%- endif %}

    {%- if field.aggregate().can_avg %}
    pub fn _avg_{{ field.name|snakecase }}(&self) -> Option<f64> {
        self.inner.get("_avg").map(|r| r.get("{{ field.name }}").cloned()).flatten().map(|v| v.as_f64()).flatten()
    }
    {%- endif %}

    {%- if field.aggregate().can_sum %}
    pub fn _sum_{{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().sum_type }}> {
        self.inner.get("_sum").map(|r| r.get("{{ field.name }}").cloned()).flatten().map(|v| v.as_{{ field.aggregate().sum_type }}()).flatten()
    }
    {%- endif %}

    {%- if field.aggregate().can_group_by %}
    pub fn {{ field.name|snakecase }}(&self) -> Option<{{ field.aggregate().group_by_type.as_ref().unwrap()|rust_ref_if_needed }}> {
        if self.inner.get("{{ field.name }}").is_some() {
            let value = self.inner.get("{{ field.name }}").unwrap().get("{{ field.name }}");
            if value.is_some() {
                value.unwrap().as_{{ field.aggregate().group_by_type.as_ref().unwrap()|rust_as }}()
            } else {
                None
            }
        } else {
            None
        }
    }
    {%- endif %}

    {%- endif %}
    {%- endfor %}

}

{%- endfor %}

pub struct Teo {
    user_ctx: UserCtx,
}

impl ExtractValueFromReqCtx for Teo {
    fn extract(param: &ReqCtx) -> Self {
        Self { user_ctx: param.user_ctx.clone() }
    }
}

impl ExtractFromCallbackParam for Teo {
    fn extract(param: &CallbackParam) -> Self {
        Self { user_ctx: param.user_ctx.clone() }
    }
}

impl ExtractFromCompareParam for Teo {
    fn extract(param: &CompareParam) -> Self {
        Self { user_ctx: param.user_ctx.clone() }
    }
}

impl From<UserCtx> for Teo {
    fn from(value: UserCtx) -> Self {
        Self { user_ctx: value }
    }
}

impl Teo {

    pub async fn transaction<F, C, Fut, R>(&self, f: F) -> Result<R> where
        F: Fn(C) -> Fut,
        C: From<UserCtx>,
        Fut: Future<Output = Result<R>> {
        self.user_ctx.transaction(f).await
    }


{%- for class in outline.classes %}
    pub fn {{ class.name|snakecase }}(&self) -> {{ class.name }}Class {
        {{ class.name }}Class { model_ctx: self.user_ctx.model_ctx("{{ class.name }}").unwrap() }
    }
{%- endfor %}
}