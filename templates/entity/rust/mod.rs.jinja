{%- if namespace.is_main() -%}
pub mod helpers;
{%- endif -%}
{%- for child in namespace.namespaces.values() -%}
{%- if !child.is_std() %}
pub mod {{ child.name() }};
{%- endif -%}
{%- endfor %}
use std::borrow::Borrow;
use std::fmt::{Debug, Display, Formatter};
use std::future::Future;
{%- if has_date %}
use chrono::NaiveDate;
{%- endif %}
{%- if has_datetime %}
use chrono::{DateTime, Utc};
{%- endif %}
{%- if has_decimal %}
use bigdecimal::BigDecimal;
{%- endif %}
{%- if has_object_id %}
use bson::oid::ObjectId;
{%- endif %}
use teo::prelude::{
    teon, model, object, Value, Result, Error, transaction,
};
use helpers::r#enum::{GeneratedEnumToValue, ValueToGeneratedEnum};
use std::marker::PhantomData;
use helpers::interface::Interface;
{%- for child in namespace.namespaces.values() -%}
{%- if !child.is_std() %}
pub use {{ child.name() }}::{{ child.name()|pascalcase }}Namespace;
{%- endif -%}
{%- endfor %}

{% for e in outline.enums() %}
/// ## {{ e.title() }}
///
/// {{ e.desc() }}
#[derive(Eq, PartialEq, Copy, Clone, Debug)]
pub enum {{ e.name() }} {
{%- for m in e.members() %}
    /// ### {{ m.title() }}
    ///
    /// {{ m.desc() }}
    {{ m.name()|snakecase|uppercase }},
{%- endfor %}
}

impl GeneratedEnumToValue for {{ e.name() }} {
    fn to_value(&self) -> Value {
        match self {
{%- for v in e.members() %}
            {{ e.name() }}::{{ v.name()|snakecase|uppercase }} => Value::String("{{ v.name() }}".to_owned()),
{%- endfor %}
        }
    }
}

impl GeneratedEnumToValue for Option<{{ e.name() }}> {
    fn to_value(&self) -> Value {
        if self.is_none() {
            return Value::Null;
        }
        match self.unwrap() {
{%- for v in e.members() %}
            {{ e.name() }}::{{ v.name()|snakecase|uppercase }} => Value::String("{{ v.name() }}".to_owned()),
{%- endfor %}
        }
    }
}

impl ValueToGeneratedEnum<{{ e.name() }}> for Value {
    fn to_enum_variant(&self) -> Result<{{ e.name() }}> {
        if self.is_string() {
            Ok(match self.as_str().unwrap() {
{%- for v in e.members() %}
                "{{ v.name() }}" => {{ e.name() }}::{{ v.name()|snakecase|uppercase }},
{%- endfor %}
                _ => return Err(Error::new("cannot convert value to enum variant"))
            })
        } else {
            Err(Error::new("cannot convert value to enum variant"))
        }
    }
}

impl ValueToGeneratedEnum<Option<{{ e.name() }}>> for Value {
    fn to_enum_variant(&self) -> Result<Option<{{ e.name() }}>> {
        if self.is_string() {
            Ok(Some(match self.as_str().unwrap() {
{%- for v in e.members() %}
                "{{ v.name() }}" => {{ e.name() }}::{{ v.name()|snakecase|uppercase }},
{%- endfor %}
                _ => return Err(Error::new("cannot convert value to enum variant"))
            }))
        } else if self.is_null() {
            Ok(None)
        } else {
            Err(Error::new("cannot convert value to enum variant"))
        }
    }
}
{%- endfor %}

{% for model in namespace.models.values() %}
/// ## {{ model.title() }}
///
/// {{ model.desc() }}
pub struct {{ model.name() }}Model {
    pub ctx: model::Ctx,
}

impl {{ model.name() }}Model {
    /// Find many {{ model.name()|wordcase|pluralize }}.
    pub async fn find_many(&self, query: impl Borrow<Value>) -> Result<Vec<{{ model.name() }}>> {
        self.ctx.find_many(query.borrow()).await
    }

    /// Find a unique {{ model.name()|wordcase }}.
    pub async fn find_unique(&self, query: impl Borrow<Value>) -> Result<Option<{{ model.name() }}>> {
        self.ctx.find_unique(query.borrow()).await
    }

    /// Find {{ model.name()|wordcase|articlize }}.
    pub async fn find_first(&self, query: impl Borrow<Value>) -> Result<Option<{{ model.name() }}>> {
        self.ctx.find_first(query.borrow()).await
    }

    /// Create a new {{ model.name()|wordcase }}.
    pub async fn new(&self, values: impl Borrow<Value>) -> Result<{{ model.name() }}> {
        self.ctx.create_object::<{{ model.name() }}>(values.borrow()).await
    }

    /// Create an empty {{ model.name()|wordcase }}.
    pub async fn default(&self) -> Result<{{ model.name() }}> {
        self.ctx.create_object::<{{ model.name() }}>(teon!({}).borrow()).await
    }

    /// Count on {{ model.name()|wordcase }}.
    pub async fn count(&self, query: impl Borrow<Value>) -> Result<usize> {
        self.ctx.count(query.borrow()).await
    }

    /// Aggregate on {{ model.name()|wordcase }}.
    pub async fn aggregate(&self, query: impl Borrow<Value>) -> Result<{{ model.name() }}AggregateResult> {
        self.ctx.aggregate(query.borrow()).await
    }

    /// Group by on {{ model.name()|wordcase }}.
    pub async fn group_by(&self, query: impl Borrow<Value>) -> Result<Vec<{{ model.name() }}AggregateResult>> {
        self.ctx.group_by(query.borrow()).await
    }
}

#[derive(Clone)]
pub struct {{ model.name() }} {
    pub inner: model::Object,
}

impl {{ model.name() }} {

    /// Whether this {{ model.name()|wordcase }} is new.
    pub fn is_new(&self) -> bool {
        self.inner.is_new()
    }

    /// Whether this {{ model.name()|wordcase }} is modified.
    pub fn is_modified(&self) -> bool {
        self.inner.is_modified()
    }

    /// Set new values to a {{ model.name()|wordcase }}. Validations and transformations are
    /// triggered.
    pub async fn set(&self, values: impl AsRef<Value>) -> Result<()> {
        self.inner.set_teon(values.as_ref()).await
    }

    /// Update with new values to a {{ model.name()|wordcase }}. Validations and transformations are
    /// not triggered.
    pub async fn update(&self, values: impl AsRef<Value>) -> Result<()> {
        self.inner.update_teon(values.as_ref()).await
    }

    /// Save this {{ model.name()|wordcase }}.
    pub async fn save(&self) -> Result<()> {
        self.inner.save().await
    }

    /// Delete this {{ model.name()|wordcase }}.
    pub async fn delete(&self) -> Result<()> {
        self.inner.delete().await
    }

{%- for field in model.fields.values() %}
    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub fn {{ field.name()|snakecase|escape_rust }}(&self) -> {{ lookup.call(field.type())? }} {
    {%- if field.type().is_enum_variant() %}
        let value: Value = self.inner.get("{{ field.name() }}").unwrap();
        value.to_enum_variant().unwrap()
    {%- else %}
        self.inner.get("{{ field.name() }}").unwrap()
    {%- endif %}
    }

    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub fn set_{{ field.name()|snakecase }}(&self, new_value: {{ lookup.call(field.type())? }}) {
    {%- if field.type().is_enum_variant() %}
        self.inner.set("{{ field.name() }}", new_value.to_value()).unwrap();
    {%- else %}
        self.inner.set("{{ field.name() }}", new_value).unwrap();
    {%- endif %}
    }
{%- endfor %}

{%- for field in model.relations.values() %}
{%- if field.type().is_array() %}
    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn {{ field.name()|snakecase|escape_rust }}(&self, find_many_input: impl AsRef<Value>) -> {{ lookup.call(field.type())? }} {
        let objects = self.inner.force_get_relation_objects("{{ field.name() }}", find_many_input.as_ref()).await.unwrap();
        objects.iter().map(|o| {{ lookup.call(field.type().unwrap_array())? }} { inner: o.clone() }).collect()
    }

    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn set_{{ field.name()|snakecase }}(&self, {{ field.name() }}: {{ lookup.call(field.type())? }}) {
        let objects = {{ field.name() }}.iter().map(|o| o.inner.clone()).collect();
        self.inner.force_set_relation_objects("{{ field.name }}", objects).await
    }

    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn add_to_{{ field.name()|snakecase }}(&self, {{ field.name }}: {{ lookup.call(field.type().unwrap_array().borrow())? }}) {
        let objects = {{ field.name() }}.iter().map(|o| o.inner.clone()).collect();
        self.inner.force_add_relation_objects("{{ field.name() }}", objects).await
    }

    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn remove_from_{{ field.name()|snakecase }}(&self, {{ field.name() }}: {{ lookup.call(field.type().unwrap_array().borrow())? }}) {
        let objects = {{ field.name() }}.iter().map(|o| o.inner.clone()).collect();
        self.inner.force_remove_relation_objects("{{ field.name() }}", objects).await
    }
{%- else %}
    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn {{ field.name()|snakecase|escape_rust }}(&self) -> {{ lookup.call(field.type())? }} {
        let object = self.inner.force_get_relation_object("{{ field.name() }}").await.unwrap();
        {% if field.is_optional() %}
        match object {
            Some(object) => Some({{ lookup.call(field.type().unwrap_optional().borrow())? }} { inner: object }),
            None => None,
        }
        {% else %}
        {{ lookup.call(field.type())? }} { inner: object.unwrap() }
        {% endif %}
    }

    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn set_{{ field.name()|snakecase }}(&self, {{ field.name() }}: {{ lookup.call(field.type())? }}) {
        self.inner.force_set_relation_object("{{ field.name }}", {% if !field.is_optional() %}Some({% endif %}{{ field.name() }}{% if field.is_optional() %}.map(|o| o.inner.clone()){% else %}.inner.clone(){% endif %}{% if !field.is_optional() %}){% endif %}).await
    }
{%- endif %}
{%- endfor %}

{%- for field in model.properties.values() %}
{%- if field.getter.is_some() %}
    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn {{ field.name()|snakecase|escape_rust }}(&self) -> Result<{{ lookup.call(field.type())? }}> {
    {%- if field.type().is_enum_variant() %}
        let value: Value = self.inner.get_property("{{ field.name() }}").await;
        value.to_enum_variant()
    {%- else %}
        self.inner.get_property("{{ field.name() }}").await
    {%- endif %}
    }
{%- endif %}
{%- if field.setter.is_some() %}
    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    pub async fn set_{{ field.name()|snakecase }}(&self, new_value: {{ lookup.call(field.type())? }}) -> Result<()> {
    {%- if field.type().is_enum_variant() %}
        self.inner.set_property("{{ field.name() }}", new_value.to_value()).await
    {%- else %}
        self.inner.set_property("{{ field.name() }}", new_value).await
    {%- endif %}

    }
{%- endif %}
{%- endfor %}
}

impl From<{{ model.name() }}> for model::Object {
    fn from(value: {{ model.name() }}) -> Self {
        value.inner.clone()
    }
}

impl From<model::Object> for {{ model.name() }} {
    fn from(value: model::Object) -> Self {
        Self { inner: value }
    }
}

impl From<{{ model.name() }}> for object::Object {
    fn from(value: {{ model.name() }}) -> Self {
        object::Object::from(value.inner.clone())
    }
}

impl From<object::Object> for {{ model.name() }} {
    fn from(value: model::Object) -> Self {
        Self { inner: value }
    }
}

impl TryFrom<object::Object> for {{ model.name() }} {

    type Error = Error;

    fn try_from(value: object::Object) -> std::result::Result<Self, Self::Error> {
        let model_object: model::Object = value.try_into()?;
        Self { inner: model_object }
    }
}

impl Debug for {{ model.name() }} {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Debug::fmt(&self.inner, f)
    }
}

impl Display for {{ model.name() }} {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.inner, f)
    }
}

{%- endfor %}

{% for interface in outline.interfaces() %}
pub trait {{ interface.name() }}Trait{{ generics_declaration(interface.generic_names()) }}: Interface {
    {%- for field in interface.fields() %}
    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    fn {{ field.name()|snakecase|escape_rust }}(&self) -> {{ lookup.call(field.type().to_optional().borrow())? }} {
    {%- if field.type().is_enum_variant() %}
        let value: Value = self.inner().get("{{ field.name() }}")?;
        value.to_enum_variant().unwrap()
    {%- else %}
        self.inner().as_dictionary().unwrap().get("{{ field.name() }}")?.into()
    {%- endif %}
    }

    /// ## {{ field.title() }}
    ///
    /// {{ field.desc() }}
    fn set_{{ field.name()|snakecase }}(&mut self, new_value: {{ lookup.call(field.type())? }}) {
    {%- if field.type().is_enum_variant() %}
        self.inner_mut().as_dictionary_mut().unwrap().insert("{{ field.name() }}".to_owned(), new_value.to_value()).unwrap();
    {%- else %}
        self.inner_mut().as_dictionary_mut().unwrap().insert("{{ field.name() }}".to_owned(), new_value.into()).unwrap();
    {%- endif %}
    }
    {%- endfor %}
}

pub struct {{ interface.name() }}{{ generics_declaration(interface.generic_names()) }} {
    inner: Value,
    phantom_data: PhantomData{{ generics_declaration(interface.generic_names()) }},
}

impl{{ generics_declaration(interface.generic_names()) }} Interface for {{ interface.name() }}{{ generics_declaration(interface.generic_names()) }} {
    fn inner(&self) -> &Value {
        &self.inner
    }

    fn inner_mut(&mut self) -> &mut Value {
        &mut self.inner
    }
}

impl{{ generics_declaration(interface.generic_names()) }} {{ interface.name() }}Trait{{ generics_declaration(interface.generic_names()) }} for {{ interface.name() }}{{ generics_declaration(interface.generic_names()) }} { }

{% for extend in unwrap_extends(interface.extends())? %}
impl{{ generics_declaration(interface.generic_names()) }} {{ extend }} for {{ interface.name() }}{{ generics_declaration(interface.generic_names()) }} { }
{% endfor %}

impl{{ generics_declaration(interface.generic_names()) }} From<Value> for {{ interface.name() }}{{ generics_declaration(interface.generic_names()) }} {
    fn from(value: Value) -> Self {
        Self { inner: value, phantom_data: PhantomData::new() }
    }
}
{% endfor %}

pub struct {% if namespace.is_main() %}Teo{% else %}{{ namespace.name()|capitalize }}Namespace{% endif %} {
    ctx: transaction::Ctx,
}

impl From<transaction::Ctx> for {% if namespace.is_main() %}Teo{% else %}{{ namespace.name()|capitalize }}Namespace{% endif %} {
    fn from(value: transaction::Ctx) -> Self {
        Self { ctx: value }
    }
}

impl {% if namespace.is_main() %}Teo{% else %}{{ namespace.name()|capitalize }}Namespace{% endif %} {

    pub async fn transaction<F, C, Fut, R>(&self, f: F) -> Result<R> where
        F: Fn(C) -> Fut,
        C: From<UserCtx>,
        Fut: Future<Output = Result<R>> {
        self.ctx.transaction(f).await
    }

    {%- for model in namespace.models.values() %}
    pub fn {{ model.name()|snakecase }}(&self) -> {{ model.name() }}Model {
        {{ model.name() }}Model { ctx: self.ctx.model_ctx_for_model_at_path({{ format_model_path(model.path()) }}).unwrap() }
    }
    {%- endfor %}

    {%- for child in namespace.namespaces.values() %}
    {%- if !child.is_std() %}
    pub fn {{ child.name()|snakecase }}(&self) -> {{ child.name()|pascalcase }}Namespace {
        {{ child.name()|pascalcase }}Namespace { ctx: self.ctx.clone() }
    }
    {%- endif %}
    {%- endfor %}
}