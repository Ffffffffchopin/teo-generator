from __future__ import annotations
from typing import Any, Optional, Literal, TypedDict, Generic, TypeVar, cast
from re import Pattern
from datetime import date, datetime
from decimal import Decimal
from teo import ObjectId, Enumerable

{%- for child in namespace.namespaces.values() %}
from . import {{ child.name()|snakecase }}
{%- endfor %}

{% for e in outline.enums() %}
{{ e.name() }} = Literal[{{ e.joined_enum_variant_names_for_python() }}]
{% endfor %}

{% for interface in outline.interfaces() %}
# **{{ interface.title() }}**
#
# {{ interface.desc() }}
class {{ interface.name() }}{% if interface.generic_names().len() > 0 %}[{{interface.joined_generic_names()}}]{% endif %}({% for t in interface.extends() %}{{ lookup.call(t).unwrap() }}, {% endfor %}TypedDict):
{% if interface.fields().is_empty() %}
    pass
{% endif %}
{% for field in interface.fields() %}
    # **{{ field.title() }}**
    #
    # {{ field.desc() }}
    {{ field.name()|snakecase_preserve_where_operator|escape_python }}: {{ lookup.call(field.type()).unwrap() }}
{% endfor %}
{% endfor %}

{% for model in namespace.models.values() %}
{%- if model.generate_entity %}
class {{ model.name() }}Model:
    async def find_many(self, query: {{ model.name() }}FindManyArgs) -> list[{{ model.name() }}]:
        return cast(Any, None)
    async def find_unique(self, query: {{ model.name() }}FindUniqueArgs) -> Optional[{{ model.name() }}]:
        return cast(Any, None)
    async def find_first(self, query: {{ model.name() }}FindFirstArgs) -> Optional[{{ model.name() }}]:
        return cast(Any, None)
    async def create(self, input: {{ model.name() }}CreateInput) -> {{ model.name() }}:
        return cast(Any, None)
    async def count(self, query: {{ model.name() }}CountArgs) -> int:
        return cast(Any, None)
    async def aggregate(self, query: {{ model.name() }}AggregateArgs) -> {{ model.name() }}AggregateResult:
        return cast(Any, None)
    async def group_by(self, query: {{ model.name() }}GroupByArgs) -> list[{{ model.name() }}AggregateResult]:
        return cast(Any, None)

class {{ model.name() }}:
    def is_new(self) -> bool:
        return cast(Any, None)
    def is_modified(self) -> bool:
        return cast(Any, None)
    async def set(self, input: {{ model.name() }}UpdateInput) -> None:
        return cast(Any, None)
    async def update(self, input: {{ model.name() }}ScalarUpdateInput) -> None:
        return cast(Any, None)
    async def save(self) -> None:
        return cast(Any, None)
    async def delete(self) -> None:
        return cast(Any, None)
    async def to_teon(self) -> {{ model.name() }}Result:
        return cast(Any, None)
    {%- for field in model.fields.values() %}
    {%- endfor %}
    {%- for field in model.relations.values() %}
    {%- endfor %}
    {%- for field in model.properties.values() %}
    {%- endfor %}
{%- endif %}
{% endfor %}

{% for path_arguments in outline.path_arguments() %}
class {{ path_arguments.name() }}(TypedDict):
{% for item in path_arguments.items() %}
    {{ item|snakecase }}: str
{% endfor %}
{% endfor %}